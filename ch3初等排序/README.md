[TOC]

## 3.1 排序

1. 排序是指将数据按照键重新排列为升序或降序的处理.
2. 选择合适的排序算法时,要注意以下特征:
   * 复杂度与稳定性
   * 除了保存数据的数组以外是否还需要别的内存.
   * 数据特征会不会对复杂度造成影响.



## 3.2 插入排序法

* 算法描述:

    ```
    //待排序数组A, 数组长度N
    InsertionSort(A)
        for i from 1 to A.lenth
            val = A[i]
            j = i -1
            while(j >= 0 && A[j] > val)
                A[j+1] = A[i]
                j--
            A[j+1] = val 
    ```



* 复杂度分析:

  > 每个i循环需要执行i次,总共需要 $1+2+..+N-1=(N^2-N)/2$次.
  >
  > 忽略常数项1/2, 又由于N与$N^2$相比可以小到足以忽略, 得出复杂度与$N^2成正比.
  >
  > 算法复杂度为$O(N^2)$.




* 算法适用性分析:

  * 在此算法中只将比`val`大的值向后平移, 不相邻的元素不会交换位置.因此整个算法十分稳定.
  * 插入算法的优势在于能很快处理相对有序的数据.



## 3.3 冒泡排序

* 算法描述 ：

  ```
  //待排序数组A
  BubbleSort(A)
  	flag = ture
  	while(flag)
  		flag = flase
  		for i form 0 to A.lenth -1
  			if A[i] > A[i+1]
  				A[i]与A[i+1]交换
  				flag = false
  ```

* 复杂度分析:

  > 在最坏的情况下总共需要执行$(N-1)+(N-2)+...+1= (N^2-N)/2$次, 算法复杂度数量级为$O(N^2)$.
  
* 算法适用性分析

  * 稳定排序, 但是若是将`A[i] > A[i+1]`变成`A[i] >= A[i+1]`就会失去稳定性.
  * 冒泡排序中的交换次数称为逆序数或反序数.



## 3.4  选择排序

* 算法描述:

  ```
  //待排序数组
  SelectionSort(A)
  	for i form 0 to A.lenth
  		min = i
  		for j from i to A.lenth
  			if A[j] < A[min]
  				min = j
  		exchange A[min] and A[i]
  ```

* 复杂度分析:

  > 无论什么情况下 都需要执行$(N-1)+(N-2)+...+1= (N^2-N)/2$次, 算法复杂度数量级为$O(N^2)$.

* 算法适用性分析

  * 会直接交换不相邻的两个元素, 以及两个元素值相同时也会交换位置, 为不稳定排序
  * 固定的算法复杂度