[TOC]

## 3.1 排序

1. 排序是指将数据按照键重新排列为升序或降序的处理.
2. 选择合适的排序算法时,要注意以下特征:
   * 复杂度与稳定性
   * 除了保存数据的数组以外是否还需要别的内存.
   * 数据特征会不会对复杂度造成影响.



## 3.2 插入排序法

* 算法描述:

    ```
    //待排序数组A, 数组长度N
    InsertionSort(A)
        for i from 1 to A.lenth
            val = A[i]
            j = i -1
            while(j >= 0 && A[j] > val)
                A[j+1] = A[i]
                j--
            A[j+1] = val 
    ```



* 复杂度分析:

  > 每个i循环需要执行i次,总共需要 $1+2+..+N-1=(N^2-N)/2$次.
  >
  > 忽略常数项1/2, 又由于N与$N^2$相比可以小到足以忽略, 得出复杂度与$N^2$成正比.
  >
  > 算法复杂度为$O(N^2)$.




* 算法适用性分析:

  * 在此算法中只将比`val`大的值向后平移, 不相邻的元素不会交换位置.因此整个算法十分稳定.
  * 插入算法的优势在于能很快处理相对有序的数据.



## 3.3 冒泡排序

* 算法描述 ：

  ```
  //待排序数组A
  BubbleSort(A)
  	flag = ture
  	while(flag)
  		flag = flase
  		for i form 0 to A.lenth -1
  			if A[i] > A[i+1]
  				A[i]与A[i+1]交换
  				flag = true
  ```

* 复杂度分析:

  > 在最坏的情况下总共需要执行$(N-1)+(N-2)+...+1= (N^2-N)/2$次, 算法复杂度数量级为$O(N^2)$.
  
* 算法适用性分析

  * 稳定排序, 但是若是将`A[i] > A[i+1]`变成`A[i] >= A[i+1]`就会失去稳定性.
  * 冒泡排序中的交换次数称为逆序数或反序数.



## 3.4 选择排序

* 算法描述:

  ```
  //待排序数组
  SelectionSort(A)
  	for i form 0 to A.lenth
  		min = i
  		for j from i to A.lenth
  			if A[j] < A[min]
  				min = j
  		exchange A[min] and A[i]
  ```

* 复杂度分析:

  > 无论什么情况下 都需要执行$(N-1)+(N-2)+...+1= (N^2-N)/2$次, 算法复杂度数量级为$O(N^2)$.

* 算法适用性分析

  * 会直接交换不相邻的两个元素, 以及两个元素值相同时也会交换位置, 为不稳定排序
  * 固定的算法复杂度



## 3.5 稳定排序

* 排序的稳定性

    * 稳定排序: 在排序处理之后,两个相同的元素先后位置不会发生改变称为稳定排序.
    * 不稳定排序: 排序处理之后, 两个相同的元素先后位置可能会发生改变.
    
* 例子:

    > 对于`H4 C9 S4 D2 C3`进行按数字位排序, 
    >
    > 使用稳定的排序方法得出的结果为:
    >
    > `D2 C3 H4 S4 C9`
    >
    > 不稳定排序:
    >
    > `D2 C3 S4 H4 C9`

## 3.6 希尔排序

* 算法描述:

  ```
  //希尔排序在针对插入排序的优点进行了优化, 希尔排序使用增量间隔使得数列的有序性不断提高.
  //增量为g的插入排序算法
    insetionSortWithGap(A,g)
    	for i form g to A.lenth
    		temp = A[g]
    		j = i -g
    		while(j>0 && a[j] > temp)
    			a[j+g] = g[j]
    			j = j - g
    		a[j+g] = temp
    		
    //生成对应A长度的增量数列
    createG(A.lenth)
    	...
    	返回数列gap
    	
    //希尔排序
    ShellSort
    	for i form gap.lenth to 0
    		insetionSortWithGap(A, gap[i])
  ```


* 复杂度分析:

  > 希尔排序的算法复杂度与增量序列的选取有密切关系,增量`g`的选择也有很多方法, 举例当$g_{n+1}=3g_n+1$时,算法复杂度基本维持在$O(N^{1.25})$.

* 适用性分析:

  * 正确选择合适的增量序列下, 算法效率较高, 为稳定排序.



## 心得总结

* 本章的在学习的时候, 先看明白了算法的思想然后使用go语言实现算法, 实现完测试完毕之后,在使用伪代码描述一遍算法, 接着分析算法的复杂度以及适用性.

