[toc]

# 7 查找

##  5.1 查找的基本概念

搜索或称查找: 是指从数据集合里找出目标的算法.



### **三种基本的搜索算法**:

#### 1. 线性搜索.

线性搜索指从数据集合的开头顺次访问各元素, 若找到就返回该元素或位置,并结束搜索,若无则返回一个特殊值表明没有搜索到值.  线性搜索效率低, 但是适用于各种数据形式

#### 2. 二分搜索

也称为二分查找法, 在基于已经排序好的数据集合基础上进行的搜索,搜索思路如下:

1. 先把整个集合区域作为搜索范围(数据集合升序排列)
2. 检查数据集合中央的元素,若与目标关键字一致则结束,若小于关键字则对前半部分做第二部的操作.
3. 若检查到数据返回数据或者数据位置,否则返回特殊值表明未查询到值.

#### 3. 散列法

散列是一种数据结构也是一种散列表的算法.此算法只需要将元素的关键字带入函数即可找出结果.



### **基本术语**:

#### 1. 查找表

**查找表**是同一类型的数据元素构成的集合. 数据元素之间存在完全松散的关系,因此查找表示一种非常灵活的数据结构, 可以使用线性表, 树表及散列表实现等

#### 2. 关键字

**关键字**是数据元素中某个数据项的值, 用它可以标识一个数据元素.

若此关键字可以唯一的标识一个记录, 称为**主关键字**, 反之可以识别若干记录的称为**次关键字**.

#### 3. 动态查找表与静态查找表

查找的同时进行修改操作,相应的表称为**动态查找表**,反之为**静态查找表**

动态查找表的表结构本身实在查找过程中动态生成的, 即创建表时,对于给定值, 若表中存在其关键字匹配到给定值的记录,则查找成功返回; 否则插入关键字等于给定值的记录

#### 4. 平均查找长度

为确定记录在查找表中的位置, 需和给定值进行进行比较关键字个数的期望值, 称为查找成功时的**平均查找长度(Average Search Length, ASL)**

对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL=∑PiCi (i=1,2,3,…,n),可以简单以数学上的期望来这么理解。其中：Pi 为查找表中第i个数据元素的概率，Ci为找到第i个数据元素时已经比较过的次数。 

查找算法的基本运算是关键字之间的比较操作, 所以可以用平均查找长度来衡量查找算法的性能.



##  5.2 线性表的查找

线性查找又称顺序查找(Linear Search/Sequential Search) 是一种最简单的查找方法，它的基本思想是从第一个记录开始，逐个比较记录的关键字，直到和给定的Key值相等，则查找成功；若比较结果与文件中n个记录的关键字都不等，则查找失败。

### 5.21 线性查找

**算法描述**:

1. 顺序搜索

    ```
    LINEAR-SERACH(A, key)
        for each i in A
            if i == key
             return i
        return NOT_FOUND
    ```
    
2. 设置监视哨的顺搜索
    将上面的算法引入标记之后可以将效率提高数倍. 所谓标记, 就是在数组等数据结构中设置一个拥有特殊值的元素.线性搜索中, 我们可以把元素放置在最后一个单元中, 然后只通过比较一次即可继续迭代.

    ```
    LINEAR-SERACH(A, key)
        i = 0
        A[n] = key
        while A[i] != key 
            i++
        if i = n
            return NOT_FOUND
        retrun i
    ```
    
    两个算法的区别在于主循环中的比较次数, 算法1需要比较两次, 一次是for循环里 , 一次是key和元素的比较, 而算法二 只需要一次不等价运算即可, 由于标记的作用可以确保不陷入死循环, 所以可以去掉结束循环条件

**算法分析**

算法二是程序设计技巧的改进, 通过设置观察哨, 去除查找过程里每次迭代都要判断是否已经搜索完整张表. 当数据量大时, 能减少近乎一半的运行时间.

两个算法的时间复杂度均为O(n).

优点: 适用于顺序结构和链式结构, 无论元素顺序均可以使用

缺点: 平均查找长度过大时, 效率低.

###  5.22 二分搜索 

Binary Search 称二分查找或折半查找, 先决条件是线性表必须使用顺序存储结构并且元素按照关键字有序排列,下列讨论中, 默认有序表是有序递增的.

**算法步骤**:

二分查找过程为: 从表的中间记录开始,若给定值和中间记录的关键字相等,则查找成功; 若给定值大于或者小于中间记录的关键字,则在表中大于或小于中间记录的那一半中查找, 重复执行,直到查找到元素或者区间为空(这时查找失败)

**算法描述**:

1. 循环写法

    ```
    BINARY-SEARCH(A, key)
        left = A's first index
        right = A's last index
        while left <= right
            mid = (right+left)/2
    		if key < A[mid]
                right = mid
    		else if key > A[mid]
                left = mid
            else
                return mid
        return NOT_FOUND
    ```
    
2. 递归写法

    ```
    BINARY-SEARCH(A, left, right, key)
    	if left > right
    		return NOT_FOUND
    	 mid = (right+left)/2
    	if key < A[mid]
        	return BINARY-SEARCH(A, key, left, mid-1)
    	else if key > A[mid]
        	return BINARY-SEARCH(A, key, mid+1, right)
        else
        	return mid
    ```

**算法分析**

二分搜索过程可以用二叉树描述. 树中每个结点对应表中的一个记录, 但节点值不是记录的关键字, 而是记录在表中的位置序号. 把mid位置作为树根, 左子表与右子表分别作为树的左子树与右子树, 得到的二叉树称为二分搜索的**判定树**.

在查找成功时进行比较的次数不超过树的深度.具有n各结点的判定树的深度为$log_2n + 1$ , 即查找成功时和给定值比较的关键字数最多为$log_2n + 1$

因此算法的时间复杂度为$O(log_2n)$.

优点:比较次数少查找效率高

缺点: 对表结构要求高, 只能用于顺序存储的有序表. 排序费时, 排序时需要进行元素的移动. 二分搜索不适合用于数据元素经常变动的线性表

### 5.23 分块查找

**分块查找(Blocking Search)/索引顺序查找**要求把一个大的线性表分解成若干块，每块中的节点可以任意存放，但块与块之间必须排序。

需要建立一个索引表, 其中包括两项内容:

- 关键字项, 其值为该子表的最大关键字
- 指针项, 指示该子表的第一个记录在表中的位置

索引表按关键字有序, 则表或者有序或者分块有序. 分块有序是指第任意的子表$i$中所有记录的关键字均大于$i-1$中的子表中的最大关键字.

查找时，首先在索引表中进行查找，确定要找的节点所在的块。由于索引表是排序的，因此，对索引表的查找可以采用顺序查找或折半查找；然后，在相应的块中采用顺序查找，即可找到对应的节点。

**算法步骤**

1. 先选取各子表中的最大关键字构成一个索引表
2. 先在索引表中查找到范围, 在进入该索引表指示的子表中进行搜索

**算法描述**

```
ADT index
	key
	left
	right

BLOCK-SEARCH(A,index[],key)
	//Get the block location which conatins the key
	i = BINARY-SEARCH(index[],key)
	//Search key in block i
	return LINEAR-SERACH(A, index[i].left,index[i].right, key)
```

**算法分析**

$ASL=L_b+L_w, L_b为查找索引表确定所在快的平均查找长度,L_w为在块中查找元素的平均查找长度$

分块查找是折半查找和顺序查找的一种改进方法，折半查找虽然具有很好的性能，但其前提条件时线性表顺序存储而且按照关键码排序，这一前提条件在结点树很大且表元素动态变化时是难以满足的。而顺序查找可以解决表元素动态变化的要求，但查找效率很低。如果既要保持对线性表的查找具有较快的速度，又要能够满足表元素动态变化的要求，则可采用分块查找的方法。

分块查找的速度虽然不如折半查找算法，但比顺序查找算法快得多，同时又不需要对全部节点进行排序。当节点很多且块数很大时，对索引表可以采用折半查找，这样能够进一步提高查找的速度。

###   5.4 散列法

1. 相关定义:

   * 散列表: 散列表是一种数据结构, 由一个存储元素的结构以及决定元素位置的函数组成.
   * 散列函数(哈希函数`Hash`): 根据给定的关键字计算出元素在散列表中位置的函数.
   * 冲突: 哈希函数计算出来的位置发生了重复就为冲突.

2. 算法描述:

   * 散列表的简单实现:

     ```
     insert(data)
     	T[h(data.key)] = data
     	
     search(data)
     	return T[h(data.key)]
     ```

     `h(k)`是根据$k$值求数组$T$的下标的函数,为散列函数.比如
     
     $h(k) = k\ mod\ m$
     
     就是一种散列函数, 指 $k除以m所得的余数$.
     
     * 开放地址法是解决单一函数过于简单导致冲突的常用手段之一, 如下是双散列结构中使用的开方地址法.
     
       $H(k) = h(k,i) = (h_1(k) + i \times h_2(k))$
     
       $i$是冲突之后计算下一次散列的次数
     
   * 使用开放地址法的散列法:
   
     ```
     h1(key) 
     	return k mod m
     	
     h2(key)
     	return 1 + key mod m
     	
     h(key, i)
     	return (h1(key) + i * h2(key)) mod m
     
     insert(T, key)
     	i = 0
     	while true
     		j = h(key, i)
     		if T[j] == NIL
     			T[j] = key
     			return j
     		else 
     			i++
     search(T, key)
     	i = 0
     	while true 
     		j = h(key, i)
     		if T[j] == key
     			return j
     		else if T[j] == NIL || i >= m
     			return NIL
     		else 
     			i++
     ```
   
   * 散列函数根据不同用途会有不一样的算法, 上述用的是求余数法.
   
3. 算法实现:

   * [hash](hash/hash.go)
