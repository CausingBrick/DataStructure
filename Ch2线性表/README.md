Table of Contents
=================

   * [2 线性表](#2-线性表)
      * [2.1 线性表的类型定义](#21-线性表的类型定义)
      * [2.2 线性表的顺序存储结构和表示](#22-线性表的顺序存储结构和表示)
         * [2.2.1 结构和特点](#221-结构和特点)
         * [2.2.2 顺序表的实现](#222-顺序表的实现)
         
# 2 线性表
## 2.1 线性表的类型定义

* 定义: 线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列,并且除开头尾元素外有且仅有一个前驱和后继元素, 而头元素仅有一个后继元素, 尾元素仅有一个前驱元素。其中n为表长。当n=0时 线性表是一个空表.

* 特点:

  * 线性表中第一个元素称为表头元素；最后一个元素称为表尾元素。
  * 除第一个元素外，每个元素有且仅有一个直接前驱。
  * 除最后一个元素外，每个元素有且仅有一个直接后继。

* 包含的结构:

  凡是满足线性表定义的结构称为线性表, 包括:

  - 串
  - 满足定义的数组
  - 链表
  - 栈和队列



## 2.2 线性表的顺序存储结构和表示

### 2.2.1 结构和特点

* 定义: 线性表的顺序存储又称为顺序表, 他是用一组连续的物理存储单元来存储线性表里的元素,若顺序表的元素个数为n, 则任一个其中的元素`i`在物理存储单元的地址为`头元素地址+i*元素内存大小`.逻辑结构和物理结构都是连续的.
* 建立顺序表的三个属性:
  1. 存储空间的起始位置(如数组名字一般代表该数组的起始地址)
  2. 顺序表的容量
  3. 顺序表的当前长度
* 特点:
  * 主要特点为随机访问: 通过首地址和元素的序号可以在O(1)的时间内找到指定的元素.
  * 顺序表的存储密度高, 每个节点只存储数据元素, 无需额外空间来存储他们之间的逻辑关系.
  * 缺点: 由于在物理存储逻辑上连续性, 对于插入和删除操作需要大量的移动操作.



### 2.2.2 顺序表的实现

1. 数组实现

   根据顺序表的存储特点,  容易发现在程序设计中数组具有随机存储的特点, 而由于线性表的长度是可以变的, 并且所需的最大存储空间随问题不同而不同. 故可以抽象出以下的结构(和Go里的`slice`大致相同)

   - ADT

       ```c
       ADT list
        array //数组的名字(也是数组的指针)指向存储空间的初始地址
        len // 线性表当前的长度
        cap	// 线性表的容量
       ```

   - 创建

     ```c
     //参数: et为初始时的数组或list, len为创建长度, cap为容量
     //返回: 返回一个内容为et线性表,长度为max(et.length, len), 容量为cap
     MakeList(et, len, cap)
     	if et.length > cap or len < cap or len < 0
     		return error
         //创建一个长度为cap的数组,并将et放入其中    
     	creat list.array[cap]
     		copy(array, et)//将et放入array
     		if et.length > len
     			list.cap = et.length
     		else
     			list.cap = len
     	return list
     ```
     
   - 插入
   
       在顺序表的L的第`i`个位置之前插入新的元素e, 需要将第`i`及之后的元素往后移动一个单位
   
       ```c
       //参数: L顺序表, e插入元素, i为插入的位置
       Insert(L,i,e)
       	if i < 1 or i > L.length //i 不合法
       		return error
       	if L.cap < L.length + 1 //存储数组不够重新分配
       		creat array[cap + 1]//创建新数组
       		copy(array, L.array)//复制元素
       		L.array = array
       		L.cap += 1//容量+1
       	copy(L.array[i+1:],L.array[i:])//将第i个及以后的元素往后移动一个单位
       	L.array[i] = e //插入元素e
       	L.len += 1 //长度加一
       ```

       复杂度分析: 操作里最多的操作是移动元素, 最坏情况下从最后一个元素开始移动, 复杂度为O(n).
   
   - 删除
   
       与插入相反, 删除L中的e之后需要将e之后的元素前移一个单位
   
       ```c
       //参数: L顺序表, i为删除的位置
       //返回值: e为删除的元素
       Delete(L,i)
           //判断i的合法性
           if i < 1 or i > L.length
               return error
            e = L.array[i-1]
            copy(L.array[i:],L.array[i+1:])
	         L.length -= 1
	         return e      	
		```
		
		复杂度分析: 操作里最多的操作是移动元素, 最坏情况下从最后一个元素开始移动, 复杂度为O(n).
		
	- 合并
	
	    将两个线性表L1,L2顺序合并在一起返回L3 ,若L1容量够大直接将L2的元素放到L1中即可, 否则就重新申请一个新的数组来存储两个顺序表的元素(不考虑放到L2因为复杂度一样)
	
	    ```c
	    Merge(L1, L2)
	    	//L1为空直接返回L2
	    	if L1.len == 0
	    		return L3 = L2
        	//L2为空返回L1
	    	if L2.len == 0
	    		return L3 = L1
	    	//L1的剩余容量够存L2,将L2移动到L1中    
	    	if L1.cap >= L1.len + L2.len
	    		L3 = L1
	    		copy(L1.array[L1.len-1:],L2.array[:])
	    		L3.len += L2.len
	    	//申请一个足够的数组将L1和L2放进去
	     MakeList(L1+L2)
	    ```
	    
	    复杂度分析: 可以看出操作最多是将两个顺序表的元素放到新的顺序表中, 算法复杂度为O(L1.len+L2.len)即O(n)
	
2. 线性表的链式实现

   链式存储的特点就是逻辑上保持连续, 但是物理存储不一定连续,相互间的前驱后继的关系存储在每个元素(结点)里, 这种抽象结构叫链表.

   

   链表的特点:

   * 优点:
     * 合并,删除,新增等操作不需要进行大量的元素移动, 只需更改相应节点的内容即可效率为
     * 在内存中可以动态的申请内存和释放比顺序表更灵活
   * 缺点:
     * 没有顺序存储随机存储的特点,读取效率为O(n)

   

   链表的类别:

   ​	根据结点里的信息使结点点间线性顺序排列有两类

   * 单向链表(single linked list)

     每个结点中的辅助数据只包含后继结点的信息

   * 双向链表(double linked list)

     每个结点中包含了前驱与后继的结点信息, 可以双向访问

     对于连接方式而言, 若将单向链表的头尾结点连接起来,即尾结点的指针指向头节点,各个元素就组成了一个环, 这样的链表叫循环链表(circular list)

     

   由于循环链表是单向链表的特殊连接方式, 而双向链表是是在单链表的基础上多了前驱指针.

   对于循环链表操作和线性链表基本一致,差别仅在于循环条件不是L.next是否为nil而是判断是否指向头结点.

   故以下只介绍双向链表的操作:
   
   - ADT
   
     ```c
     //由一个个结点Node组成
     ADT Node
    	next	//指向后继的指针
     	pre	//指向前驱的指针
    	key	// 关键字即存储的的信息
     ```

   - 搜索
   
     Search(L, k)查找链表L中的第一个关键字为k的元素,并返回该元素的指针.若寻找不到吗则该过程返回nil.
   
     ```c
     Search(L, k)
     	x = L.head
    	while x != nil and x.key != k
     		x = x.next
    	return x
     ```

     搜索一个含有n个结点的链表, 最坏的运行时间为O(n), 因为可能需要搜索整个链表.

   - 链表的插入
   
     给定一个饿设置好关键字key的元素x, 过程Insert将 x连接到链表的前端
   
     ```c
     Insert(L,x)
     	x.next = L.head
     	if L.head != nil
     		L.head.prev = x
     	L.head = x
    	x.prev = nil
     ```

     在一个含n个元素的链表上执行的效率为O(1).

   - 链表的删除
   
     Delete(L, x)将一个元素x从链表L中删除.过程中需要给定一个指向x的指针,然后通过修改一些指针将x移除出链表.若要删除具有给定关键字的元素,则别绪先调用Search算法找到该元素
   
     ```c
     Delete(L,x)
     	if x.prev != nil
             x.prev.next = x.next
     	else L.head = x.next
         if x.next != nil
     		x.next.prev = x.prev
     ```
     
     时间复杂度为O(1). 但是如果要删除给定关键字的元素, 则最坏情况下的时间为O(n)
   
   