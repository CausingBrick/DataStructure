## 8 树结构

## 8.1相关定义

* 树: 树（tree）是包含n（n>=0）个结点的有穷集，其中：

  （1）每个元素称为结点（node）；

  （2）有一个特定的结点被称为根结点或树根（root）。

  （3）除根结点之外的其余数据元素被分为m（m≥0）个互不相交的集合T1，T2，……Tm-1，其中每一个集合Ti（1<=i<=m）本身也是一棵树，被称作原树的子树（subtree）。

  把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。

* 空集合也是树，称为空树。空树中没有结点。

* 结点的度：一个结点含有的子树的个数称为该结点的度；

* 叶结点或终端结点：度为0的结点称为叶结点；

* 非终端结点或分支结点：度不为0的结点；

* 双亲结点或父结点：若一个结点含有子结点，则这个结点称为其子结点的父结点；

* 孩子结点或子结点：一个结点含有的子树的根结点称为该结点的子结点；

* 兄弟结点：具有相同父结点的结点互称为兄弟结点；

* 树的度：一棵树中，最大的结点的度称为树的度；

* 结点的层次：从根开始定义起，根为第1层，根的子结点为第2层，以此类推；

* 树的高度或深度：树中结点的最大层次,节点到根的最长路径；

* 堂兄弟结点：双亲在同一层的结点互为堂兄弟；

* 结点的祖先：从根到该结点所经分支上的所有结点；

* 子孙：以某结点为根的子树中任一结点都称为该结点的子孙。

* 森林：由m（m>=0）棵互不相交的树的集合称为森林；



### 8.1.1 树的分类

* 无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树;

* 有序树 : 树中任意节点的子结点之间有顺序关系，这种树称为有序树；

* 二叉树：每个节点最多含有两个子树的树称为二叉树；

* 完全二叉树 : 完全二叉树是由[满二叉树](https://baike.baidu.com/item/满二叉树)而引出来的。对于深度为K的，有n个结点的二叉树，当且仅当其每一个结点都与深度为K的满二叉树中编号从1至n的结点一一对应时称之为完全二叉树;

* 满二叉树 : 除最后一层无任何子[节点](https://baike.baidu.com/item/节点/865052)外，每一层上的所有结点都有两个子结点的二叉树。

* 霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；



## 8.2 有根树的表达

1. 左子右兄弟表示法,各节点具有一下信息:
- 节点u的父节点
- 节点u最左侧的子节点
- 节点u右侧紧邻的兄弟节点

2. 实现的数据结构,可以使用结构体数组或者三个数组实现:
	```
	struct node{int parent, left, right}
	tree []node

	//or

	parent,left, right int[]
	```

3. 算法:  
	使用结构体数组表示树,u为单个结构体节点
	- 求节点在树的深度:

		循环法:
		```
		depth(u)
			d = 0
			while u.parent != nil
				u = u.parent
				d++
			return d
		```
		递归法:
		```
		recDepth(u)
			if u.parent == nil {
				return 0
			}
			return recDepth(u.Parent) + 1
		```
	- 打印树的子节点列表:
		```
		printChildren(u)
			c = u.left
			while c != nil {
				print c
				c = tree[c].right
			}
		```
	[点击查看源码](tree/rooted.go)



## 8.3 二叉树的表达

- `二叉树`的定义: 若一棵树拥有一个根节点, 且所有的节点的子节点书都不超过2, 那么该树即为有根二叉树.

- 特点: 由于子节点不超过两个, 且子节点有左右子节点之分, 故当只有一个子节点时, 要严格区分是左子节点还是右子节点.

- `有序树`:子节点有特定顺序的树.

- 表达:

  > 二叉树T可以递归进行定义. 满足下列条件之一的树即为二叉树
  >
  > - T没有任何节点
  > - T由以下三个不包含共通元素的顶点集合构成
  >   - root 
  >   - left subtree
  >   - right  subtree

- 算法:

  二叉树有根数是有根树的一个特殊子集, 故对于有根数的算法二叉树都适用.

	[点击查看源码](tree/binary.go)

## 8.3 树的遍历

**三类遍历方法:**

1. 前序遍历(Preorder Tree Walk) :按照根节点, 左子树, 右子树的顺序访问节点.

   ```
   preParse(u)
   	if u == nill
   		return 
   	print u
   	preParse(T[u].left)
   	preParse(T[u].right)
   ```

2. 中序遍历(Inorder Tree Walk): 按照左子树, 根节点, 右子树的顺序访问节点.

   ```
   inParse(u)
   	if u == nill
   		return 
   	preParse(T[u].left)
   	print u
   	preParse(T[u].right)
   ```

   

3. 后序遍历(postorder Tree Walk): 按照左子树, 右子树, 根节点的顺序访问树.

   ```
   postParse(u)
   		if u == nill
   		return 
   	preParse(T[u].left)
   	preParse(T[u].right)
   	print u
   ```



## 8.4 树的重建


若将树按照前序与中序输出, 根据此按后序遍历树.

- 分析:
