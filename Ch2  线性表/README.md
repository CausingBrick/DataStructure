# 2 线性表
## 2.1 线性表的类型定义

* 定义: 线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列,并且除开头尾元素外有且仅有一个前驱和后继元素, 而头元素仅有一个后继元素, 尾元素仅有一个前驱元素。其中n为表长。当n=0时 线性表是一个空表.

* 特点:

  * 线性表中第一个元素称为表头元素；最后一个元素称为表尾元素。
  * 除第一个元素外，每个元素有且仅有一个直接前驱。
  * 除最后一个元素外，每个元素有且仅有一个直接后继。

* 包含的结构:

  凡是满足线性表定义的结构称为线性表, 包括:

  - 串
  - 满足定义的数组
  - 链表
  - 栈和队列



## 2.2 线性表的顺序存储结构和表示

### 2.2.1 结构和特点

* 定义: 线性表的顺序存储又称为顺序表, 他是用一组连续的物理存储单元来存储线性表里的元素,若顺序表的元素个数为n, 则任一个其中的元素`i`在物理存储单元的地址为`头元素地址+i*元素内存大小`.逻辑结构和物理结构都是连续的.
* 建立顺序表的三个属性:
  1. 存储空间的起始位置(如数组名字一般代表该数组的起始地址)
  2. 顺序表的容量
  3. 顺序表的当前长度
* 特点:
  * 主要特点为随机访问: 通过首地址和元素的序号可以在O(1)的时间内找到指定的元素.
  * 顺序表的存储密度高, 每个节点只存储数据元素, 无需额外空间来存储他们之间的逻辑关系.
  * 缺点: 由于在物理存储逻辑上连续性, 对于插入和删除操作需要大量的移动操作.



### 2.2.2 顺序表的实现

1. 数组实现

   根据顺序表的存储特点,  容易发现在程序设计中数组具有随机存储的特点, 而由于线性表的长度是可以变的, 并且所需的最大存储空间随问题不同而不同. 故可以抽象出以下的结构(和Go里的`slice`大致相同)

   - ADT

       ```c
       ADT list
        array //数组的名字(也是数组的指针)指向存储空间的初始地址
        len // 线性表当前的长度
        cap	// 线性表的容量
       ```

   - 创建

     ```c
     //参数: et为初始时的数组或list, len为创建长度, cap为容量
     //返回: 返回一个内容为et线性表,长度为max(et.length, len), 容量为cap
     MakeList(et, len, cap)
     	if et.length > cap or len < cap or len < 0
     		return error
         //创建一个长度为cap的数组,并将et放入其中    
     	creat list.array[cap]
     		copy(array, et)//将et放入array
     		if et.length > len
     			list.cap = et.length
     		else
     			list.cap = len
     	return list
     ```
     
   - 插入
   
       在顺序表的L的第`i`个位置之前插入新的元素e, 需要将第`i`及之后的元素往后移动一个单位
   
       ```c
       //参数: L顺序表, e插入元素, i为插入的位置
       Insert(L,i,e)
       	if i < 1 or i > L.length //i 不合法
       		return error
       	if L.cap < L.length + 1 //存储数组不够重新分配
       		creat array[cap + 1]//创建新数组
       		copy(array, L.array)//复制元素
       		L.array = array
       		L.cap += 1//容量+1
       	copy(L.array[i+1:],L.array[i:])//将第i个及以后的元素往后移动一个单位
       	L.array[i] = e //插入元素e
       	L.len += 1 //长度加一
       ```

       复杂度分析: 操作里最多的操作是移动元素, 最坏情况下从最后一个元素开始移动, 复杂度为O(n).
   
   - 删除
   
       与插入相反, 删除L中的e之后需要将e之后的元素前移一个单位
   
       ```c
       //参数: L顺序表, i为删除的位置
       //返回值: e为删除的元素
       Delete(L,i)
           //判断i的合法性
           if i < 1 or i > L.length
               return error
            e = L.array[i-1]
            copy(L.array[i:],L.array[i+1:])
	         L.length -= 1
	         return e      	
		```
		
		复杂度分析: 操作里最多的操作是移动元素, 最坏情况下从最后一个元素开始移动, 复杂度为O(n).
		
	- 合并
	
	    将两个线性表L1,L2顺序合并在一起返回L3 ,若L1容量够大直接将L2的元素放到L1中即可, 否则就重新申请一个新的数组来存储两个顺序表的元素(不考虑放到L2因为复杂度一样)
	
	    ```c
	    Merge(L1, L2)
	    	//L1为空直接返回L2
	    	if L1.len == 0
	    		return L3 = L2
        	//L2为空返回L1
	    	if L2.len == 0
	    		return L3 = L1
	    	//L1的剩余容量够存L2,将L2移动到L1中    
	    	if L1.cap >= L1.len + L2.len
	    		L3 = L1
	    		copy(L1.array[L1.len-1:],L2.array[:])
	    		L3.len += L2.len
	    	//申请一个足够的数组将L1和L2放进去
	     MakeList(L1+L2)
	    ```
	    
	    复杂度分析: 可以看出操作最多是将两个顺序表的元素放到新的顺序表中, 算法复杂度为O(L1.len+L2.len)即O(n)
